<html>
<header>
    {% load otree %}
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.0.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.0.4/dist/Draggable.min.js"></script>

    <script src="{% static 'global/js/officer.js' %}"></script>
    <script src="{% static 'global/js/harvest.js' %}"></script>
    <script src="{% static 'global/js/steal.js' %}"></script>

    <link rel="stylesheet" type="text/css" href="{% static 'global/styles/harvest.css' %}"></link>
    <link rel="stylesheet" type="text/css" href="{% static 'global/styles/steal.css' %}"></link>
    <link rel="stylesheet" type="text/css" href="{% static 'global/styles/officer.css' %}"></link>
    <link rel="stylesheet" type="text/css" href="{% static 'global/styles/main.css' %}"></link>
    <link rel="stylesheet" type="text/css" href="{% static 'global/styles/notificationlog.css' %}"></link>

    <script>
        // data is rendered on api here, then later read by vue instance
        var player = {{ pjson|json }};
        var dtokens = {{ dtokens|json }};
        var frameSize = {{ balance_update_rate }};
        var playerId = {{ player.id }};
        var groupPlayerId = {{ player.id_in_group }};
        var groupId = {{ player.group_id }};
        var harvestScreen = '{{ timeout }}' === 'True';
        var income = {{ player.income }};
        var stealStart = {{ player.steal_start }};
        var roundNumber = {{ subsession.round_number }};
        var sessionId = {{ subsession.session_id }};
        var defendTokenTotal = {{ defend_token_total }};
        var timeout = '{{ timeout }}' === 'True';
        var tutorialDuration = {{ tutorial_duration }};
        var aMax = {{ a_max }};
        var beta = {{ beta }};

        var civilianFine = {{ civilian_fine }};
        var mapSize = {{ civilian_map_size }};
        var defendTokenSize = {{ defend_token_size }};

    </script>
</header>
<body>

    <form method="post" role="form" id="form" autocomplete="off" style="display:none">
        {% csrf_token %}
        <button class="otree-btn-next btn btn-primary">Next</button>
    </form>

    {% verbatim %}
    <div>
        <div id="app" v-show="gameStarted">
            <officer-game-component
                id="officerGame"
                class="game-container"
                v-if="isOfficer"
                :maps="maps"
                :officer-units="officerTokens"
                :officer-income="income"
                :investigation-count="investigationCount"
                :defend-token-total="defendTokenTotal"
                :prob-culprit="probabilityCulprit"
                :prob-innocent="probabilityInnocent"
                :police-log-messages="policeLogMessages"
                :map-size="mapSize"
                :defend-token-size="defendTokenSize"
                @token-drag="tokenDrag"
                @token-update="tokenUpdate"
                @investigation-update="investigationUpdate"
                @defense-token-reset="defenseTokenReset">
            </officer-game-component>
            <div id="harvestGame" class="game-container" v-else>
                <harvest-items-component
                        v-if="harvestScreen"
                        class="harvest"
                        style="display:flex;"
                        :harvest-status="harvestStatus"
                        :income="income"
                        @harvest-update="harvestUpdate">
                </harvest-items-component>
                <steal-game-component
                        v-show="!harvestScreen"
                        ref="stealcomponent"
                        :maps="maps"
                        :group-player-id="groupPlayerId"
                        :player-location="playerLocation"
                        :investigation-count="investigationCount"
                        :defend-token-total="defendTokenTotal"
                        :prob-culprit="probabilityCulprit"
                        :prob-innocent="probabilityInnocent"
                        :police-log-messages="policeLogMessages"
                        :map-size="mapSize"
                        :steal-location="stealLocation"
                        :active-steal="activeSteal"
                        :active-steal-maps="activeStealMaps"
                        :fine-notification="fineNotification"
                        @location-drag="locationDrag"
                        @location-update="locationUpdate"
                        @location-token-reset="locationTokenReset">
                </steal-game-component>
                <div v-show="!isOfficer" @click='toggle' class='toggle'>{{ harvestScreen ? 'Steal' : 'Harvest'}}</div>
            </div>
            <div class="panel game-status-container">
                <div class="balance-container">
                    <div class="balance-label">Balance (<img src="https://i.imgur.com/BQXgE3F.png" alt="grain" style="height: 20px;">)</div>
                    <div class="balance" :style="{ color: balanceColor }"> {{Math.floor(balance)}}</div>
                </div>
                <div class="notifications-container">
                    <div class="notification-label">
                        News
                        <div class="steal-notification">{{stealNotification}}</div>
                    </div>
                    <div class="notification-log-container">
                        <div class="notification-log-column">
                            <div class="header"><div>Civilian<br>map</div></div>
                            <div class="content" ref="notificationLog1">
                                <div
                                    v-for="message in messages" :class="{ selfmessage: message.map == groupPlayerId }" style="width: 100%;"
                                    v-bind:style="{background: (message.map == groupPlayerId) ? 'darkgrey' : (messageIndex == message.messageIndex ? 'white' : '#eeeeee')}"
                                >{{message.map}}</div>
                            </div>
                        </div>
                        <div class="notification-log-column">
                            <div class="header"><div>Civilian<br>punished</div></div>
                            <div class="content" ref="notificationLog2">
                                <div
                                    v-for="message in messages"
                                    v-bind:style="{background: (message.punished==groupPlayerId) ? 'rgba(224,53,49, .5)' : (messageIndex == message.messageIndex ? 'white' : '#eeeeee')}"
                                >{{message.punished}}</div>
                            </div>
                        </div>
                        <div class="notification-log-column">
                            <div class="header"><div>Officer<br>reprimand</div></div>
                            <div class="content" ref="notificationLog3">
                                <div
                                    v-for="message in messages"
                                    v-bind:style="{background: (isOfficer && message.reprimand < 0) ? 'rgba(224,53,49, .5)' : (messageIndex == message.messageIndex ? 'white' : '#eeeeee')}"
                                >{{message.reprimand}}</div>
                            </div>
                        </div>
                        <div class="notification-log-column">
                            <div class="header"><div>Officer<br>bonus</div></div>
                            <div class="content" ref="notificationLog4">
                                <div
                                    v-for="message in messages"
                                    v-bind:style="{background: (isOfficer && message.bonus > 0) ? 'rgba(81,179,100,.5)' : (messageIndex == message.messageIndex ? 'white' : '#eeeeee')}"
                                >{{message.bonus}}</div>
                            </div>
                        </div>
                    </div>

                    <!--<button @click="addMessage">add message</button>-->
                </div>
            </div>
        </div>
        {% endverbatim %}
    </div>

</body>

    <!-- timeout script -->
    {#<script src="{% static 'global/js/advance_slowest.js' %}"></script>#}

    <script>
        // auto advance code
        var ReconnectingWebSocket=function(){"use strict";var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(t,n)};function t(t,n){function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}function n(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var o,r,i=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(o=i.next()).done;)s.push(o.value)}catch(e){r={error:e}}finally{try{o&&!o.done&&(n=i.return)&&n.call(i)}finally{if(r)throw r.error}}return s}var o=function(){return function(e,t){this.target=t,this.type=e}}(),r=function(e){function n(t,n){var o=e.call(this,"error",n)||this;return o.message=t.message,o.error=t,o}return t(n,e),n}(o),i=function(e){function n(t,n,o){void 0===t&&(t=1e3),void 0===n&&(n="");var r=e.call(this,"close",o)||this;return r.wasClean=!0,r.code=t,r.reason=n,r}return t(n,e),n}(o),s=function(){if("undefined"!=typeof WebSocket)return WebSocket},c={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+4e3*Math.random(),minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:1/0,maxEnqueuedMessages:1/0,startClosed:!1,debug:!1};return function(){function e(e,t,n){var o=this;void 0===n&&(n={}),this._listeners={error:[],message:[],open:[],close:[]},this._retryCount=-1,this._shouldReconnect=!0,this._connectLock=!1,this._binaryType="blob",this._closeCalled=!1,this._messageQueue=[],this.onclose=void 0,this.onerror=void 0,this.onmessage=void 0,this.onopen=void 0,this._handleOpen=function(e){o._debug("open event");var t=o._options.minUptime,n=void 0===t?c.minUptime:t;clearTimeout(o._connectTimeout),o._uptimeTimeout=setTimeout(function(){return o._acceptOpen()},n),o._ws.binaryType=o._binaryType,o._messageQueue.forEach(function(e){return o._ws.send(e)}),o._messageQueue=[],o.onopen&&o.onopen(e),o._listeners.open.forEach(function(t){return o._callEventListener(e,t)})},this._handleMessage=function(e){o._debug("message event"),o.onmessage&&o.onmessage(e),o._listeners.message.forEach(function(t){return o._callEventListener(e,t)})},this._handleError=function(e){o._debug("error event",e.message),o._disconnect(void 0,"TIMEOUT"===e.message?"timeout":void 0),o.onerror&&o.onerror(e),o._debug("exec error listeners"),o._listeners.error.forEach(function(t){return o._callEventListener(e,t)}),o._connect()},this._handleClose=function(e){o._debug("close event"),o._clearTimeouts(),o._shouldReconnect&&o._connect(),o.onclose&&o.onclose(e),o._listeners.close.forEach(function(t){return o._callEventListener(e,t)})},this._url=e,this._protocols=t,this._options=n,this._options.startClosed&&(this._shouldReconnect=!1),this._connect()}return Object.defineProperty(e,"CONNECTING",{get:function(){return 0},enumerable:!0,configurable:!0}),Object.defineProperty(e,"OPEN",{get:function(){return 1},enumerable:!0,configurable:!0}),Object.defineProperty(e,"CLOSING",{get:function(){return 2},enumerable:!0,configurable:!0}),Object.defineProperty(e,"CLOSED",{get:function(){return 3},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"CONNECTING",{get:function(){return e.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"OPEN",{get:function(){return e.OPEN},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"CLOSING",{get:function(){return e.CLOSING},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"CLOSED",{get:function(){return e.CLOSED},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"binaryType",{get:function(){return this._ws?this._ws.binaryType:this._binaryType},set:function(e){this._binaryType=e,this._ws&&(this._ws.binaryType=e)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"retryCount",{get:function(){return Math.max(this._retryCount,0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"bufferedAmount",{get:function(){return this._messageQueue.reduce(function(e,t){return"string"==typeof t?e+=t.length:t instanceof Blob?e+=t.size:e+=t.byteLength,e},0)+(this._ws?this._ws.bufferedAmount:0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"extensions",{get:function(){return this._ws?this._ws.extensions:""},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"protocol",{get:function(){return this._ws?this._ws.protocol:""},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"readyState",{get:function(){return this._ws?this._ws.readyState:this._options.startClosed?e.CLOSED:e.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"url",{get:function(){return this._ws?this._ws.url:""},enumerable:!0,configurable:!0}),e.prototype.close=function(e,t){void 0===e&&(e=1e3),this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),this._ws?this._ws.readyState!==this.CLOSED?this._ws.close(e,t):this._debug("close: already closed"):this._debug("close enqueued: no ws instance")},e.prototype.reconnect=function(e,t){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,this._ws&&this._ws.readyState!==this.CLOSED?(this._disconnect(e,t),this._connect()):this._connect()},e.prototype.send=function(e){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",e),this._ws.send(e);else{var t=this._options.maxEnqueuedMessages,n=void 0===t?c.maxEnqueuedMessages:t;this._messageQueue.length<n&&(this._debug("enqueue",e),this._messageQueue.push(e))}},e.prototype.addEventListener=function(e,t){this._listeners[e]&&this._listeners[e].push(t)},e.prototype.removeEventListener=function(e,t){this._listeners[e]&&(this._listeners[e]=this._listeners[e].filter(function(e){return e!==t}))},e.prototype._debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this._options.debug&&console.log.apply(console,function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e}(["RWS>"],e))},e.prototype._getNextDelay=function(){var e=this._options,t=e.reconnectionDelayGrowFactor,n=void 0===t?c.reconnectionDelayGrowFactor:t,o=e.minReconnectionDelay,r=void 0===o?c.minReconnectionDelay:o,i=e.maxReconnectionDelay,s=void 0===i?c.maxReconnectionDelay:i,u=0;return this._retryCount>0&&(u=r*Math.pow(n,this._retryCount-1))>s&&(u=s),this._debug("next delay",u),u},e.prototype._wait=function(){var e=this;return new Promise(function(t){setTimeout(t,e._getNextDelay())})},e.prototype._getNextUrl=function(e){if("string"==typeof e)return Promise.resolve(e);if("function"==typeof e){var t=e();if("string"==typeof t)return Promise.resolve(t);if(t.then)return t}throw Error("Invalid URL")},e.prototype._connect=function(){var e=this;if(!this._connectLock&&this._shouldReconnect){this._connectLock=!0;var t=this._options,n=t.maxRetries,o=void 0===n?c.maxRetries:n,r=t.connectionTimeout,i=void 0===r?c.connectionTimeout:r,u=t.WebSocket,a=void 0===u?s():u;if(this._retryCount>=o)this._debug("max retries reached",this._retryCount,">=",o);else{if(this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),void 0===(h=a)||!h||2!==h.CLOSING)throw Error("No valid WebSocket class provided");var h;this._wait().then(function(){return e._getNextUrl(e._url)}).then(function(t){e._closeCalled||(e._debug("connect",{url:t,protocols:e._protocols}),e._ws=e._protocols?new a(t,e._protocols):new a(t),e._ws.binaryType=e._binaryType,e._connectLock=!1,e._addListeners(),e._connectTimeout=setTimeout(function(){return e._handleTimeout()},i))})}}},e.prototype._handleTimeout=function(){this._debug("timeout event"),this._handleError(new r(Error("TIMEOUT"),this))},e.prototype._disconnect=function(e,t){if(void 0===e&&(e=1e3),this._clearTimeouts(),this._ws){this._removeListeners();try{this._ws.close(e,t),this._handleClose(new i(e,t,this))}catch(e){}}},e.prototype._acceptOpen=function(){this._debug("accept open"),this._retryCount=0},e.prototype._callEventListener=function(e,t){"handleEvent"in t?t.handleEvent(e):t(e)},e.prototype._removeListeners=function(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))},e.prototype._addListeners=function(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))},e.prototype._clearTimeouts=function(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)},e}()}();
        function makeReconnectingWebSocket(path) {
            // https://github.com/pladaria/reconnecting-websocket/issues/91#issuecomment-431244323
            var ws_scheme = window.location.protocol === "https:" ? "wss" : "ws";
            var ws_path = `${ws_scheme}://${window.location.host}${path}`;
            var socket = new ReconnectingWebSocket(ws_path);
            socket.onclose = function (e) {
                if (e.code === 1011) {
                    // this may or may not exist in child pages.
                    var serverErrorDiv = document.getElementById("websocket-server-error");
                    if (serverErrorDiv) {
                        // better to put the message here rather than the div, otherwise it's confusing when
                        // you do "view source" and there's an error message.
                        serverErrorDiv.innerText = "Server error. Check the server logs or Sentry.";
                        serverErrorDiv.style.visibility = "visible";
                    }
                }
            };
            return socket;
        }
        let socketUrl = "{{ view.socket_url|safe }}";
        let redirectUrl = "{{ view.redirect_url|safe }}";
        function initWebSocket() {
            socket = makeReconnectingWebSocket(socketUrl);

            // <disconnected-alert>
            // var alertStyle = document.querySelector('#disconnected-alert').style;
            socket.onopen = function (e) {
                // alertStyle.visibility = 'hidden';
            };

            socket.onclose = function (e) {
                if (isDebug === 'True') {
                    console.log('channel closed')
                    // alertStyle.visibility = 'visible';
                }
            };
            // </disconnected-alert>

            socket.onmessage = function (e) {
                var data = JSON.parse(e.data);

                if (data.error) {
                    console.log('Error receiving websocket message. Maybe the server was stopped.')
                }

                if (data.auto_advanced) {
                    console.log('Received redirect message', e.data);
                    window.location.href = redirectUrl;
                }
            };

        }
        initWebSocket()
    </script>

    {% verbatim %}
    <script>

        let app = new Vue({
            el: '#app',
            components: {
                'harvest-items-component': harvestItemsComponent,
                'steal-game-component': stealGameComponent,
                'officer-game-component': officerGameComponent,
                'probability-bar-component': probabilityBarComponent,
            },
            data: {
                gameStarted: true,
                player: {},
                isOfficer: true,
                playerId: null,
                groupPlayerId: null,
                groupId: null,
                roundNumber: null,
                sessionId: null,
                playerLocation: {},
                stealLocation: -1,
                policeLogMessages : [],
                messages: [],
                singleMessage: null,
                maps: [],
                balance: 0,
                balanceColor: 'black',
                roi: 0,
                income: null,
                harvestItems: [],
                harvestStatus: 0,
                harvestScreen: true,
                officerTokens: [],
                investigationCount: 0,
                defendTokenTotal: 0,
                stealNotification: "",
                defendTokenSize: 5,
                mapSize: 50,
                gameDuration: 240000,  // milliseconds
                balanceFrequency: 10000,
                activeSteal: 0,
                activeStealMaps: {1:0, 2:0, 3:0, 4:0, 5:0},
                beta: -1,
                aMax: -1,
                fineNotification: "",
                civilianFine: -1,
                messageIndex: 0,
                timeout: null,
                tutorialDuration: null,
            },
            created: function () {

                // todo we need to add way to make sure page was not refreshed or way to get timmer of actualy game instead of starting the timmer again.

                this.player = JSON.parse(player);


                this.playerId = playerId;
                this.groupPlayerId = groupPlayerId;
                this.groupId = groupId;
                this.isOfficer = this.groupPlayerId == 1;
                // this.harvestScreen = harvestScreen;
                this.roundNumber = roundNumber;
                this.sessionId = sessionId;
                this.defendTokenTotal = defendTokenTotal;
                this.stealLocation = parseInt(stealStart);
                this.balanceFrequency = frameSize;
                this.aMax = aMax;
                this.beta = beta;

                this.civilianFine = civilianFine;
                this.mapSize = mapSize;
                this.defendTokenSize = defendTokenSize;

                this.timeout = timeout;
                if (this.timeout) {
                    this.gameDuration = this.tutorialDuration;
                }

                // debug
                this.income = parseInt(income);

                // this code is for handling page refreshes
                //if (!this.isOfficer) {
                //    this.playerLocation = {
                //        'player': this.groupPlayerId,
                //        'map': this.player.map,
                //        'x': this.player.x,
                //        'y': this.player.y
                //    }; // todo integrate this into app
                //} else
                if (this.isOfficer) {
                    this.officerTokens = JSON.parse(dtokens);
                }
                //    console.log(this.officerTokens);
                    // todo
                    // this.defendTokenSlots = new Array.fill(9).fill(0)
                    // this.officerTokens.forEach(function(ot) {
                    //     if (ot.slot) {
                    //         this.defendTokenSlots[ot.number-1]
                    //     }
                    // })
                //}

                // player maps
                this.maps = [1, 2, 3, 4, 5];

                //this.gameSyncSocket = new WebSocket('ws://' + window.location.host + '/delegated_punishment/sync/' + this.groupId + '/')
                //this.gameSyncSocket.onopen = (e) => {
                //    console.log('game sync connected')
                //    data = {
                //        'group_id': this.groupId,
                //        'player_id': this.playerId,
                //        'round_number': this.roundNumber,
                //        'join': true,
                //    };
                //    this.gameSyncSocket.send(JSON.stringify(data))
                //};
                //
                //this.gameSyncSocket.onmessage = (e) => {
                //    let data = JSON.parse(e.data)
                //    if (data.start_time) {
                //        let t = data.start_time;
                //        console.log('start_time', t)
                //        this.gameStarted = true;
                //        this.startTimer();
                //    }
                //};


                // todo look into routing questions
                this.gameSocket = new WebSocket('ws://' + window.location.host + '/delegated_punishment/' + this.groupId + '/')
                    this.gameSocket.onopen = (e) => {
                        this.startTimer()
                    };

                    this.gameSocket.onmessage = (e) => {
                        let data = JSON.parse(e.data);
                        if (data.balance) {
                            this.activeStealMaps = data.balance.active_maps
                            let latestBalance = data.balance[this.groupPlayerId].balance
                            let stealingFromPlayer = data.balance[this.groupPlayerId].victim_count
                            this.activeSteal = data.balance[this.groupPlayerId].map

                            if (latestBalance === this.balance) { // balance has not changed
                                this.balanceColor = "black"
                            } else if (latestBalance < this.balance) { // balance decreasing
                                this.balanceColor = "red"
                            } else {
                                // balance increasing
                                this.balanceColor = "green"
                            }

                            this.balance = latestBalance;
                            this.roi = data.roi
                        } else if (data.intersections) {
                            // console.log(data.intersections);
                            this.messageIndex++;
                            data.intersections.forEach((i) => {
                                this.addMessage(i);

                                this.showIntersection(i);
                            })
                        } else if (data.investigation_update || data.investigation_update === 0) {
                            this.investigationCount = data.investigation_update
                        }
                    };

                this.gameSocket.onclose = (e) => {
                    console.error('CHANNEL CLOSED UNEXPECTEDLY');
                };

                if (this.isOfficer)
                     this.subscribeToBalance()

            },
            methods: {
                gameReady: function() {
                    console.log('game ready function')
                },
                toggle: function() {
                    if (this.harvestScreen) { // toggle to steal
                        // update local harvest status
                        this.harvestStatus = 0;
                        // send toggle event to db
                        this.stealActive();

                        this.harvestScreen = !this.harvestScreen;

                        this.positionStealToken();

                    } else { // toggle to harvest
                        // reset steal location
                        // this.resetLocation(Math.floor(Math.random() * 10)+1);

                        // reset harvest status and send toggle event to db
                        this.harvestScreen = !this.harvestScreen;
                        this.harvestActive();
                    }
                },
                gameUpdate: function(data) {

                    // todo can we merge objects here like we do with update() on the backend
                    data.player_id = this.playerId
                    data.group_id = this.groupId
                    data.round_number = this.roundNumber
                    data.session_id = this.sessionId

                    this.gameSocket.send(JSON.stringify(data));
                },
                stealActive: function() {
                    // screen was toggled to steal
                    this.gameUpdate({
                        'toggle': {harvest: false},
                    });
                },
                harvestActive: function() {
                    this.stealLocation = Math.floor(Math.random() * 9)+1;
                    this.gameUpdate({
                        'toggle': {harvest: true, steal_reset: this.stealLocation},
                    });
                },
                harvestUpdate: function (status) {
                    this.harvestStatus++;

                    this.gameUpdate({
                        'harvest': {status: this.harvestStatus},
                    });

                    // reset harvest cycle
                    if (this.harvestStatus == 4) {
                        this.harvestStatus = 0;
                        // reset harvest items
                        gsap.to('#seed, #water, #plow, #harvest', 0, {autoAlpha: 1});
                    }
                },
                subscribeToBalance: function () {
                    setInterval(() => {
                        if (this.gameSocket.readyState == WebSocket.OPEN) {
                            this.gameUpdate({
                                'balance': true,
                            });
                        } else {
                            console.log('the web socket is not connected')
                        }
                    }, this.balanceFrequency);
                },
                positionStealToken: function() {
                    if (this.harvestScreen) // update this so we dont check multiple times
                        return;
                    this.$nextTick(() => {
                         this.$refs.stealcomponent.setStealLocation();
                    });
                },
                resetLocation: function (location) {
                    if (location == 1) {

                    } else {

                    }
                    gsap.to('#location', 0, {x: 0, y: 0});
                },
                tokenDrag: function(token) {
                    this.gameUpdate({
                        'defend_token_drag': token,
                    });
                },
                tokenUpdate: function (token) {
                    this.gameUpdate({
                        'defend_token_update': token,
                    });
                },
                investigationUpdate: function(item) {
                    // inform the api that the item is being dragged
                    item.map = 0;
                    this.gameUpdate({
                        'investigation_update': item,
                    });
                },
                locationDrag: function(location) {
                    this.gameUpdate({
                        'steal_token_drag': location,
                    });
                },
                locationUpdate: function (location) {
                    this.gameUpdate({
                        'steal_token_update': location,
                    });
                },
                locationTokenReset: function(x) {
                    // this function informs the api that the token has reset
                    this.stealLocation = x
                    this.gameUpdate({
                        'steal_token_reset': {'steal_location': x,},
                    });
                },
                defenseTokenReset: function(tokenNumber) {
                    this.gameUpdate({
                        'defend_token_reset': tokenNumber,
                    });
                },
                showIntersection: function (i) {

                    if (this.isOfficer) {
                        // intersection-label-' + (map+1) + '-' + (player_id + 1)
                        if (i.officer_reprimand) {
                            this.stealNotification = "You were reprimanded!";
                            setTimeout(() => {
                                this.stealNotification = '';
                            }, 2000);
                        }

                        let labelElement = document.getElementById('intersection-label-' + i.map + "-" + i.culprit);
                        // determine text for label
                        let labelText = -1;
                        let labelColor = 'powderblue';
                        if (i.officer_reprimand) {
                            labelText = -1 * (i.officer_reprimand - i.officer_bonus);
                            labelColor = 'red';
                        } else if (i.officer_bonus > 0){
                            labelText = '+' + i.officer_bonus;
                            labelColor = 'green';
                        } else {
                            labelText = '0';
                            labelColor = 'black';
                        }
                        labelElement.style.color = labelColor;
                        labelElement.innerText = labelText;

                        let intersectionSelector = '#indicator-' + i.map + '-' + i.culprit;
                        let labelSelector = '#intersection-label-' + i.map + '-' + i.culprit;
                        let tl = gsap.timeline();
                        let x = i.culprit_x - 3;
                        let y = i.culprit_y - 3;

                        tl.to(intersectionSelector, 0, {left: x+1, top: y+1});
                        tl.to(labelSelector, 0, {left: x-13, top: y-30});
                        tl.to(intersectionSelector + ',' + labelSelector, {visibility: 'visible'});
                        tl.to(intersectionSelector + ',' + labelSelector, {visibility: 'hidden', delay: 2})


                    } else {
                        // was player the culprit
                        if (i.culprit == this.groupPlayerId) {
                            // this.resetLocation(i.reset_location);
                            this.stealLocation = i.steal_reset
                            this.positionStealToken()
                        }

                        if (i.guilty == this.groupPlayerId) {
                            this.fineNotification = "Fined -" + this.civilianFine;

                            this.stealNotification = "You were fined!";
                            setTimeout(() => {
                                this.stealNotification = '';
                                this.fineNotification = '';
                            }, 2000);
                        }

                        let selector = '#indicator-' + i.map + '-' + i.culprit;
                        let tl = gsap.timeline();
                        let x = i.culprit_x - 3;
                        let y = i.culprit_y - 3;

                        tl.to(selector, 0, {left: x+1, top: y+1});
                        tl.to(selector, {visibility: 'visible'});
                        tl.to(selector, {visibility: 'hidden', delay: 2})
                    }

                },
                addMessage: function(message) {
                    this.messages.push({
                        "map": message.map,
                        "punished": message.guilty ? message.guilty : 'None',
                        "bonus": message.officer_bonus ? message.officer_bonus : 0,
                        "reprimand": message.officer_reprimand ? message.officer_reprimand * -1 : 0, // todo: make this better
                        "messageIndex": this.messageIndex,
                    });
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    })
                },
                scrollToBottom: function() {
                    let nScrollHeight = this.$refs.notificationLog1.scrollHeight;

                    this.$refs.notificationLog1.scrollTop = nScrollHeight;
                    this.$refs.notificationLog2.scrollTop = nScrollHeight;
                    this.$refs.notificationLog3.scrollTop = nScrollHeight;
                    this.$refs.notificationLog4.scrollTop = nScrollHeight;

                },
                startTimer: function() {
                    if (this.groupPlayerId == 1) {
                        // set start time
                        this.gameUpdate({
                            'period_update': {'period_start': true},
                        });
                    }
                    // start 4 minute timer
                    setTimeout(() => {
                        // officer records period end
                        if (this.groupPlayerId == 1)
                            this.periodEndEvent();

                        // close socket
                        this.gameSocket.close()
                        document.getElementById('form').submit()
                    }, this.gameDuration); // 4 minute periods

                },
                periodEndEvent: function() {
                    this.gameUpdate({
                        'period_update': { 'period_end': true },
                    });
                }
            },
            computed: {
                probabilityCulprit() {
                    if (this.investigationCount > this.aMax)
                        return this.beta * 100;
                    else {
                        return Math.round((2 + this.investigationCount) * (9/80)*10000) / 100
                    }
                },
                probabilityInnocent() {
                    if (this.investigationCount > this.aMax)
                        return 0;
                    else {
                        return Math.round((6 - this.investigationCount) * (9/240)*10000) / 100
                    }
                }
            },
        });
    </script>
    {% endverbatim %}
</html>